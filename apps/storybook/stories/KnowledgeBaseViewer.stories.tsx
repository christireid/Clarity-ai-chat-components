import type { Meta, StoryObj } from '@storybook/react'
import { KnowledgeBaseViewer } from '@clarity-chat/react'
import type { KnowledgeBase, KnowledgeBaseSection } from '@clarity-chat/types'

const meta = {
  title: 'Components/KnowledgeBaseViewer',
  component: KnowledgeBaseViewer,
  parameters: {
    layout: 'padded',
  },
  tags: ['autodocs'],
  argTypes: {
    onUpdate: { action: 'updated' },
    onDelete: { action: 'deleted' },
    onExport: { action: 'exported' },
  },
} satisfies Meta<typeof KnowledgeBaseViewer>

export default meta
type Story = StoryObj<typeof meta>

const baseSections: KnowledgeBaseSection[] = [
  {
    id: 'kb-1',
    title: 'React Hooks Best Practices',
    content: `## useState
- Always use functional updates when new state depends on old state
- Initialize state with a function for expensive computations

## useEffect
- Always specify dependencies array
- Clean up side effects with return function
- Avoid using object dependencies`,
    tags: ['react', 'hooks', 'javascript'],
    confidence: 0.95,
    sources: [
      {
        type: 'message',
        id: 'msg-1',
        reference: 'Conversation on 2024-01-15',
      },
      {
        type: 'message',
        id: 'msg-2',
        reference: 'Conversation on 2024-01-20',
      },
    ],
    createdAt: new Date('2024-01-15'),
    updatedAt: new Date('2024-01-20'),
  },
  {
    id: 'kb-2',
    title: 'TypeScript Tips',
    content: `## Type Safety
- Use strict mode in tsconfig.json
- Prefer interfaces over types for objects
- Use union types instead of enums when possible

## Generics
- Keep generics simple and meaningful
- Use extends for type constraints
- Default generic types when appropriate`,
    tags: ['typescript', 'types', 'javascript'],
    confidence: 0.88,
    sources: [
      {
        type: 'message',
        id: 'msg-3',
        reference: 'Conversation on 2024-01-18',
      },
    ],
    createdAt: new Date('2024-01-18'),
    updatedAt: new Date('2024-01-18'),
  },
  {
    id: 'kb-3',
    title: 'API Design Principles',
    content: `## RESTful APIs
- Use proper HTTP methods (GET, POST, PUT, DELETE)
- Return appropriate status codes
- Version your API (v1, v2)

## GraphQL
- Design schema-first
- Use fragments for reusable fields
- Implement proper error handling`,
    tags: ['api', 'rest', 'graphql'],
    confidence: 0.72,
    sources: [
      {
        type: 'message',
        id: 'msg-4',
        reference: 'Conversation on 2024-01-22',
      },
      {
        type: 'message',
        id: 'msg-5',
        reference: 'Conversation on 2024-01-23',
      },
    ],
    createdAt: new Date('2024-01-22'),
    updatedAt: new Date('2024-01-23'),
  },
]

const baseKnowledgeBase: KnowledgeBase = {
  id: 'kb-base',
  userId: 'user-1',
  projectId: 'proj-1',
  sections: baseSections,
  metadata: {
    totalSections: baseSections.length,
    lastUpdated: new Date(),
    autoGenerated: true,
  },
  createdAt: new Date('2024-01-15'),
  updatedAt: new Date('2024-01-23'),
}

export const Default: Story = {
  args: {
    knowledgeBase: baseKnowledgeBase,
  },
}

export const SingleSection: Story = {
  args: {
    knowledgeBase: {
      ...baseKnowledgeBase,
      sections: [baseSections[0]],
      metadata: {
        ...baseKnowledgeBase.metadata,
        totalSections: 1,
      },
    },
  },
}

export const ManySections: Story = {
  args: {
    knowledgeBase: {
      ...baseKnowledgeBase,
      sections: [
        ...baseSections,
        {
          id: 'kb-4',
          title: 'CSS Best Practices',
          content: 'Use CSS custom properties for theming...',
          tags: ['css', 'styling'],
          confidence: 0.85,
          sources: [],
          createdAt: new Date(),
          updatedAt: new Date(),
        },
        {
          id: 'kb-5',
          title: 'Git Workflow',
          content: 'Use feature branches and pull requests...',
          tags: ['git', 'version-control'],
          confidence: 0.92,
          sources: [],
          createdAt: new Date(),
          updatedAt: new Date(),
        },
        {
          id: 'kb-6',
          title: 'Testing Strategies',
          content: 'Write unit tests, integration tests, and e2e tests...',
          tags: ['testing', 'quality'],
          confidence: 0.78,
          sources: [],
          createdAt: new Date(),
          updatedAt: new Date(),
        },
      ],
      metadata: {
        ...baseKnowledgeBase.metadata,
        totalSections: 6,
      },
    },
  },
}

export const LowConfidence: Story = {
  args: {
    knowledgeBase: {
      ...baseKnowledgeBase,
      sections: [
        {
          ...baseSections[0],
          confidence: 0.45,
          tags: ['react', 'experimental'],
        },
      ],
    },
  },
}

export const HighConfidence: Story = {
  args: {
    knowledgeBase: {
      ...baseKnowledgeBase,
      sections: [
        {
          ...baseSections[0],
          confidence: 0.98,
          sources: [
            {
              type: 'message',
              id: 'msg-1',
              reference: 'Verified conversation',
            },
            {
              type: 'message',
              id: 'msg-2',
              reference: 'Official documentation',
            },
            {
              type: 'message',
              id: 'msg-3',
              reference: 'Expert review',
            },
          ],
        },
      ],
    },
  },
}

export const NoSources: Story = {
  args: {
    knowledgeBase: {
      ...baseKnowledgeBase,
      sections: [
        {
          ...baseSections[0],
          sources: [],
        },
      ],
    },
  },
}

export const LongContent: Story = {
  args: {
    knowledgeBase: {
      ...baseKnowledgeBase,
      sections: [
        {
          ...baseSections[0],
          content: `# React Hooks Complete Guide

## Introduction
React Hooks revolutionized how we write React components by allowing us to use state and other React features without writing a class.

## useState
The useState hook lets you add state to functional components:

\`\`\`jsx
const [count, setCount] = useState(0)
\`\`\`

### Best Practices
- Use multiple state variables for unrelated data
- Use functional updates when new state depends on old state
- Initialize with a function for expensive computations

## useEffect
The useEffect hook lets you perform side effects:

\`\`\`jsx
useEffect(() => {
  document.title = \`Count: \${count}\`
  return () => {
    // Cleanup
  }
}, [count])
\`\`\`

### Best Practices
- Always specify dependencies
- Clean up subscriptions and timers
- Avoid using object dependencies

## useContext
Access context values without prop drilling:

\`\`\`jsx
const theme = useContext(ThemeContext)
\`\`\`

## Custom Hooks
Create reusable logic:

\`\`\`jsx
function useLocalStorage(key, initialValue) {
  const [value, setValue] = useState(() => {
    return localStorage.getItem(key) || initialValue
  })
  
  useEffect(() => {
    localStorage.setItem(key, value)
  }, [key, value])
  
  return [value, setValue]
}
\`\`\`

This is a much longer content section that demonstrates how the component handles extensive markdown content with multiple sections, code blocks, and formatting.`,
        },
      ],
    },
  },
}

export const MixedTags: Story = {
  args: {
    knowledgeBase: {
      ...baseKnowledgeBase,
      sections: baseSections.map((section, idx) => ({
        ...section,
        tags: [
          ...section.tags,
          idx % 2 === 0 ? 'frontend' : 'backend',
          idx % 3 === 0 ? 'advanced' : 'beginner',
        ],
      })),
    },
  },
}
